# %%--- [html]
# properties:
#   run_on_load: true
# ---%%
<meta charset="utf-8">

<!-- Create an element where the map will take place -->
<div id="container" style="border:solid 1px lightgrey;">
    <svg id="choropleth" width=980 height=830 style="border:solid 1px lightgrey; border-radius:5px"></svg>
    <div style="padding:10px">
        Filtern nach Kategorie: 
        <select id="selectButton" style="border-color: lightgrey; border-radius:5px">
            <option value="all">Alle Kategorien</option>
        </select>
    </div>
</div>
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
// load d3.js
await import("https://d3js.org/d3.v6.js")

const base_path = "https://raw.githubusercontent.com/JJestel/Data-Visualization/main/Sprint_2/data/"

var fahrraddiebstahl = await d3.csv(base_path + "fahrraddiebstahl.csv")

var demographie = await d3.json(base_path + "demographie/demographie_kombiniert_plr.json")

var kriminalitaet = await d3.csv(base_path + "kriminalitaet_2021_fallzahlen_bzr.csv")

var lor = await d3.csv(base_path + "LOR_2021.csv")

// 542 planungsräume
var planungsraeume = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_planungsraeume_2021_wgs84.geojson")
// 143 bezirksregionen
var bezirksregionen = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_bezirksregionen_2021_wgs84.geojson")
// 58 prognoseraeume
var prognoseraeume = await d3.json(base_path + "GeoJSON/EPSG_4326/lor_prognoseraeume_2021_wgs84.geojson")
// 12 bezirke
var bezirke = await d3.json(base_path + "GeoJSON/EPSG_4326/bezirksgrenzen.geojson")
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
planungsraeume
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
demographie
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
kriminalitaet
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
lor
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
count_per_lor = d3.rollup(fahrraddiebstahl, v => v.length, d => d.LOR)

// for (const pr of count_per_lor.keys()) {
//  x = count_per_lor.get(pr) / (demog[pr].gesamt || 1) * 100000
//  count_per_lor.set(pr, x);
// }

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
// assign svg element to variable
var svg = d3.select("#choropleth")

// helper function to format numbers with points
function formatNumber(num) {
    return num.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.')
}

# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
function render_choropleth(data, {
    targetSVG,
    colorScale,
    fillFeature,
    lorGeoJSON,
    tooltip,
  	legend,
} = {}) {

    // ------------------------------------------------------------------------------------
    // Enable Zoom

    // enable (limited) zoom and pan 
    // var zoom = d3.zoom()
    //     .scaleExtent([1, 4])
    //     .translateExtent([[0, 0], [980, 850]])
    //     .on('zoom', function (event) {
    //         targetSVG.selectAll('path')
    //             .attr('transform', event.transform);
    //             targetSVG.selectAll('.circle')
    //             .attr('transform', event.transform);
    //     });
    // targetSVG.call(zoom);

    // ------------------------------------------------------------------------------------
    // Create Tooltip

    const Tooltip = d3.select("#container")
        .append("div")
        .style("opacity", 0)
        .attr("class", "tooltip")
        .style("background-color", "white")
        .style("border", "solid")
        .style("border-color", "grey")
        .style("border-width", "2px")
        .style("border-radius", "5px")
        .style("padding", "5px")


    // functions that change the tooltip when user hover / move / leave a cell
    const mouseover_lor = function (event, d) {
        d3.select(this)
            .style("stroke-width", 3)
            .style("stroke-opacity", 1)

        Tooltip
            .transition()
            .duration(150)
            .style("opacity", 1)
    }

    const mousemove_lor = function (event, d) {
        Tooltip
            .html(tooltip(d))
            .style("left", (event.pageX + 20) + "px")
            .style("top", (event.pageY) + "px")
    }
    const mouseleave_lor = function (event, d) {
        d3.select(this)
            .style("stroke-width", 1)
            .style("stroke-opacity", 0.5)

        if (event.toElement.tagName != 'circle') {
            Tooltip
                .transition()
                .duration(150)
                .style("opacity", 0);
        }
    }


    // ------------------------------------------------------------------------------------
    // Create Map


    // Map and projection
    const path = d3.geoPath();
    const projection = d3.geoMercator()
        .scale(80000)
        .center([13.424, 52.507])
        .translate([+svg.attr("width") / 2, +svg.attr("height") / 2]);

    // reset svg element
    targetSVG.node().innerHTML = ''



    // LOR Ebene Zeichen
    targetSVG.append("g")
        .selectAll("path")
        .data(lorGeoJSON.features)
        .join("path")
        .on("mouseover", mouseover_lor)
        .on("mousemove", mousemove_lor)
        .on("mouseleave", mouseleave_lor)
        .attr("d", d3.geoPath().projection(projection))
        .attr("fill", colorScale(0))
        .transition()
        .duration(800)
        .attr("fill", d => colorScale(fillFeature(d)))
        .attr("class", d => 'lor_area')
        .attr("stroke", "black")
        .attr("stroke-opacity", "50%")

    // Bezirksgrenzen zeichen
    targetSVG.append("g")
        .selectAll("path")
        .data(bezirke.features)
        .join("path")
        .attr("d", d3.geoPath().projection(projection))
        .attr("fill", "none")
        .attr("stroke", "black")
        .attr("stroke-width", 2)


    // ------------------------------------------------------------------------------------
    // Create Legend


    // add white background for legend
    // svg.append('rect')
    //     .attr('x', 770)
    //     .attr('y', 0)
    //     .attr('width', 280)
    //     .attr('height', 235)
    //     .attr('stroke', 'transparent')
    //     .attr('fill', 'orange')
    //     .attr('ry', 5)
    

    // legend color rectangles
    const size = 20
    const x_test_start = 850

    svg.append("g")
        .selectAll("legend-rect")
        .data(colorScale.range())
        .enter()
        .append("rect")
        .attr("x", x_test_start)
        .attr("y", (d, i) => 50 + i * (size + 5) ) // 100 is where the first dot appears. 25 is the distance between dots
        .attr("width", size)
        .attr("height", size)
        .style("fill", d => d)

    // legend text
    svg.append("g").selectAll("legend_text")
        .data([legend.start, ...colorScale.domain()])
        .enter()
        .append("text")
        .attr("x", x_test_start + size * 1.25)
        .attr("y", (d, i) => 50 + i * (size + 5) + (size / 2)) // 100 is where the first dot appears. 25 is the distance between dots
        .style("fill", d => d)
        .text((d,i) => d + " - " + [legend.start, ...colorScale.domain(), legend.end][i+1] )
        .attr("text-anchor", "left")
        .style("alignment-baseline", "middle")

    // legend title
    svg.append("text")
        .attr("x", x_test_start)
        .attr("y", 30)
        //.style("fill", "DimGrey")
        .text(d => legend.title)
        .attr("text-anchor", "left")
        .style("alignment-baseline", "middle")

}




var colorScale = d3.scaleThreshold()
    .domain([6.0, 14.0, 30.0, 62.0, 94])
    .range(['#fef0d9', '#fdd49e', '#fdbb84', '#fc8d59', '#e34a33', '#b30000']);


render_choropleth(fahrraddiebstahl, {
    targetSVG: svg,
    colorScale: colorScale,
    fillFeature: d => count_per_lor.get(d.properties.PLR_ID) || 0,
    lorGeoJSON: planungsraeume,
    tooltip: d => d.properties.PLR_NAME + '<br>' + (count_per_lor.get(d.properties.PLR_ID) || 0) + ' Fälle',
  	legend: {start: 0, end: 233, title: 'Fallzahlen'}
})

# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/diverging-bar-chart
function DivergingBarChart(data, {
  x = d => d, // given d in data, returns the (quantitative) x-value
  y = (d, i) => i, // given d in data, returns the (ordinal) y-value
  title, // given d in data, returns the title text
  marginTop = 30, // top margin, in pixels
  marginRight = 40, // right margin, in pixels
  marginBottom = 10, // bottom margin, in pixels
  marginLeft = 40, // left margin, in pixels
  width = 640, // outer width of chart, in pixels
  height, // the outer height of the chart, in pixels
  xType = d3.scaleLinear, // type of x-scale
  xDomain, // [xmin, xmax]
  xRange = [marginLeft, width - marginRight], // [left, right]
  xFormat, // a format specifier string for the x-axis
  xLabel, // a label for the x-axis
  yPadding = 0.1, // amount of y-range to reserve to separate bars
  yDomain, // an array of (ordinal) y-values
  yRange, // [top, bottom]
  colors = d3.schemePiYG[3] // [negative, …, positive] colors
} = {}) {
  // Compute values.
  const X = d3.map(data, x);
  const Y = d3.map(data, y);

  // Compute default domains, and unique the y-domain.
  if (xDomain === undefined) xDomain = d3.extent(X);
  if (yDomain === undefined) yDomain = Y;
  yDomain = new d3.InternSet(yDomain);

  // Omit any data not present in the y-domain.
  // Lookup the x-value for a given y-value.
  const I = d3.range(X.length).filter(i => yDomain.has(Y[i]));
  const YX = d3.rollup(I, ([i]) => X[i], i => Y[i]);

  // Compute the default height.
  if (height === undefined) height = Math.ceil((yDomain.size + yPadding) * 25) + marginTop + marginBottom;
  if (yRange === undefined) yRange = [marginTop, height - marginBottom];

  // Construct scales, axes, and formats.
  const xScale = xType(xDomain, xRange);
  const yScale = d3.scaleBand(yDomain, yRange).padding(yPadding);
  const xAxis = d3.axisTop(xScale).ticks(width / 80, xFormat);
  const yAxis = d3.axisLeft(yScale).tickSize(0).tickPadding(6);
  const format = xScale.tickFormat(100, xFormat);

  // Compute titles.
  if (title === undefined) {
    title = i => `${Y[i]}\n${format(X[i])}`;
  } else if (title !== null) {
    const O = d3.map(data, d => d);
    const T = title;
    title = i => T(O[i], i, data);
  }

  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  svg.append("g")
      .attr("transform", `translate(0,${marginTop})`)
      .call(xAxis)
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
          .attr("y2", height - marginTop - marginBottom)
          .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
          .attr("x", xScale(0))
          .attr("y", -22)
          .attr("fill", "currentColor")
          .attr("text-anchor", "center")
          .text(xLabel));

  const bar = svg.append("g")
    .selectAll("rect")
    .data(I)
    .join("rect")
      .attr("fill", i => colors[X[i] > 0 ? colors.length - 1 : 0])
      .attr("x", i => Math.min(xScale(0), xScale(X[i])))
      .attr("y", i => yScale(Y[i]))
      .attr("width", i => Math.abs(xScale(X[i]) - xScale(0)))
      .attr("height", yScale.bandwidth());

  if (title) bar.append("title")
      .text(title);

  svg.append("g")
      .attr("text-anchor", "end")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
    .selectAll("text")
    .data(I)
    .join("text")
      .attr("text-anchor", i => X[i] < 0 ? "end" : "start")
      .attr("x", i => xScale(X[i]) + Math.sign(X[i] - 0) * 4)
      .attr("y", i => yScale(Y[i]) + yScale.bandwidth() / 2)
      .attr("dy", "0.35em")
      .text(i => format(X[i]));

  svg.append("g")
      .attr("transform", `translate(${xScale(0)},0)`)
      .call(yAxis)
      .call(g => g.selectAll(".tick text")
        .filter(y => YX.get(y) < 0)
          .attr("text-anchor", "start")
          .attr("x", 6));

  return svg.node();
}
# %%--- [python]
# properties:
#   run_on_load: true
# ---%%
import pandas as pd
import pyodide
# %% [markdown]
# Korrelation mit Kriminalität 2021
# %%--- [python]
# properties:
#   run_on_load: true
# ---%%
from js import fahrraddiebstahl, lor
fd = pd.DataFrame.from_dict(fahrraddiebstahl.to_py())

lors = pd.DataFrame(lor.to_py())
cols = ['Planungsraum (Nummer)', 'Planungsraum (Name)', 'Bezirksregion (Nummer)', 'Bezirksregion (Name)']
fd = fd.merge(lors[cols], left_on='LOR', right_on='Planungsraum (Nummer)')

print(fd)
# %%--- [python]
# properties:
#   run_on_load: true
# ---%%
from js import kriminalitaet

crime = pd.DataFrame(kriminalitaet.to_py())
crime_fd = crime.merge(fd.groupby(by='Bezirksregion (Nummer)').size().to_frame().rename(columns={0: 'Fahrraddiebstähle'}), left_on='LOR-Schlüssel (Bezirksregion)', right_index=True, how='right')
num_cols = crime_fd.columns[2:]
crime_fd[num_cols] = crime_fd[num_cols].astype(float)
crime_correlation = crime_fd.corr()['Fahrraddiebstähle'].sort_values(ascending=False).to_dict()
print(crime_correlation)
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
let result_py = pyodide.globals.get("crime_correlation")
var crime_correlation = result_py.toJs()
result_py.destroy()

chart = DivergingBarChart(Array.from(crime_correlation, x => x).slice(1), {
    x: d => d[1],
    y: d => d[0],
    yDomain: Array.from(crime_correlation, x => x[0]).slice(1),
    xDomain: [0, 1],
    xFormat: "+f",
    xLabel: "Pearson's Correlation Coefficient",
    width: 980,
    height: 830,
    marginRight: 70,
    marginLeft: 200,
    colors: d3.schemeRdBu[3]
})

// create and show new div
div = document.createElement("div")
d3.select(div).append(x => chart)
d3.select(div).node()
# %% [markdown]
# Korrelation mit Sozialstruktur
# %%--- [python]
# properties:
#   run_on_load: true
# ---%%
from js import fahrraddiebstahl, demographie

demo = pd.DataFrame.from_dict(demographie.to_py(), orient='index')
print(demo)
# %%--- [python]
# properties:
#   run_on_load: true
# ---%%
demo_fd = demo.merge(fd.groupby(by='LOR').size().to_frame().rename(columns={0: 'Fahrraddiebstähle'}), left_on='PLR-ID', right_index=True, how='left')
correlation = demo_fd.corr()['Fahrraddiebstähle'].sort_values(ascending=False).to_dict()
print(correlation)
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
let result_py = pyodide.globals.get("correlation")
var result_js = result_py.toJs();
result_py.destroy();
result_js


chart = DivergingBarChart(Array.from(result_js, x => x).slice(1), {
    x: d => d[1],
    y: d => d[0],
    yDomain: Array.from(result_js, x => x[0]).slice(1),
    xDomain: [-0.8, 0.8],
    xFormat: "+f",
    xLabel: "Pearson's Correlation Coefficient",
    width: 980,
    height: 830,
    marginRight: 70,
    marginLeft: 70,
    colors: d3.schemeRdBu[3]
})

// append to existing div
// d3.select('#container_2').node().innerHTML = ''
// d3.select('#container_2').append(x => chart)
// < div id = "container_2" style = "border:solid 1px lightgrey;"> </div>

// create and show new div
div = document.createElement("div")
d3.select(div).append(x => chart)
d3.select(div).node()